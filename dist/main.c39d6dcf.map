{"version":3,"sources":["ts/State/State.ts","ts/Transition/Transition.ts","ts/Automaton/Automaton.ts","main.ts","../../../../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/bundle-url.js","../../../../../../../AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/css-loader.js"],"names":["bundleURL","getBundleURLCached","getBundleURL","Error","err","matches","stack","match","getBaseURL","url","replace","exports","bundle","require","updateLink","link","newLink","cloneNode","onload","remove","href","split","Date","now","parentNode","insertBefore","nextSibling","cssTimeout","reloadCSS","setTimeout","links","document","querySelectorAll","i","length","module"],"mappings":"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","file":"main.c39d6dcf.map","sourceRoot":"..","sourcesContent":["import {Transition} from \"../Transition/Transition\";\r\nclass State {\r\n\tpublic id: number;\r\n\tpublic readonly transitions: Set<Transition>;\r\n\r\n\t/**\r\n\t * Crea un estado.\r\n\t *\r\n\t * @param id {identidiacdor del estado}\r\n\t */\r\n\tconstructor(id: number) {\r\n\t\tthis.id = id;\r\n\t\tthis.transitions = new Set<Transition>();\r\n\t}\r\n\r\n\t/**\r\n\t * Agrega una transición al conjunto de transiciones del estado.\r\n\t *\r\n\t * @param {Transition} t {transición a ser agregada}\r\n\t * @memberof State\r\n\t */\r\n\taddTransition = (t: Transition) => {\r\n\t\tthis.transitions.add(t);\r\n\t};\r\n\r\n\t/**\r\n\t * Obtiene el subconjunto del conjunto de transiciones que tengan el símbolo symbol.\r\n\t *\r\n\t * @param {string} symbol {símbolo con el que se hace la transición}\r\n\t * @memberof State\r\n\t */\r\n\tpublic getTransitionsBySymbol = (symbol: string) => {\r\n\t\treturn [...this.transitions].filter( transition => {\r\n\t\t\tif (transition.hasLimitSymbol()) {\r\n\t\t\t\treturn symbol.length === 1 ? transition.symbol <= symbol && symbol <= transition.limitSymbol : false;\r\n\t\t\t} else {\r\n\t\t\t\treturn transition.symbol === symbol;\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n}\r\n\r\nexport {State};\r\n","import {State} from \"../State/State\";\r\n\r\nclass Transition {\r\n\tpublic symbol: string;\r\n\tpublic limitSymbol: string;\r\n\tpublic targetState: State;\r\n\r\n\tconstructor (symbol: string, targetState: State, limitSymbol?: string) {\r\n\t\t// Se sgrega el símbolo principal de la transición.\r\n\t\tthis.symbol = symbol;\r\n\t\t// Se establece el estado objetivo.\r\n\t\tthis.targetState = targetState;\r\n\t\t// Se establece el símbolo límite (para rangos), si existe.\r\n\t\tif (limitSymbol) {\r\n\t\t\tif (symbol.length != 1 || limitSymbol.length != 1) {\r\n\t\t\t\tconsole.log(\"La longitud de ambos símbolos para un rango debe ser 1\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tif (limitSymbol <= symbol) {\r\n\t\t\t\tconsole.log(\"No es posible crear la transición con ese rango.\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tthis.limitSymbol = limitSymbol;\r\n\t\t} else {\r\n\t\t\tthis.limitSymbol = null;\r\n\t\t}\r\n\t}\r\n\r\n\thasLimitSymbol = () => {\r\n\t\treturn this.limitSymbol ? true : false;\r\n\t}\r\n}\r\nexport {Transition};","import {State} from \"../State/State\";\nimport {Transition} from \"../Transition/Transition\";\nimport \"../../css/table.css\";\n\nclass Automaton {\n\t/**\n\t * Alfabeto del autómata.\n\t *\n\t * @private\n\t * @type {Set<string>}\n\t * @memberof Automaton\n\t */\n\tprivate sigma: Set<string>;\n\n\t/**\n\t * Conjunto de estados del autómata.\n\t *\n\t * @private\n\t * @type {Set<State>}\n\t * @memberof Automaton\n\t */\n\tprivate states: Set<State>;\n\n\t/**\n\t * Estado inicial del autómata.\n\t *\n\t * @private\n\t * @type {State}\n\t * @memberof Automaton\n\t */\n\tprivate startState: State;\n\n\t/**\n\t * Conjunto de estados de aceptación del autómata.\n\t *\n\t * @private\n\t * @type {Set<State>}\n\t * @memberof Automaton\n\t */\n\tprivate acceptStates: Set<State>;\n\n\t/**\n\t * Símbolo que actúa como la cadena vacía del autómata.\n\t *\n\t * @static\n\t * @type {string}\n\t * @memberof Automaton\n\t */\n\tstatic readonly epsilon: string = \"\\u03B5\";\n\n\t/**\n\t * Genera un autómata vacío.\n\t *\n\t * @memberof Automaton\n\t */\n\tconstructor() {\n\t\tthis.sigma = new Set<string>();\n\t\tthis.sigma.clear();\n\t\tthis.states = new Set<State>();\n\t\tthis.states.clear();\n\t\tthis.startState = null;\n\t\tthis.acceptStates = new Set<State>();\n\t\tthis.acceptStates.clear();\n\t\tconsole.log(\"Automata vacío creado.\");\n\t}\n\n\t/**\n\t * Crea un autómata básico de una transición con el símbolo symbol.\n\t *\n\t * @param {string} symbol {es el símbolo con el que se genera la transición}\n\t * @param {string} [limitSymbol] {es un símbolo opcional que delimita el rango [symbol, limitSymbol]}\n\t * @memberof Automaton\n\t */\n\tpublic readonly createBasic = (symbol: string, limitSymbol?: string) => {\n\t\tlet state0, state1;\n\t\tif(this.states.size == 0){\n\t\t\tstate0 = new State(0);\n\t\t\tstate1 = new State(1);\n\t\t}\n\t\telse{\n\t\t\tstate0 = new State(this.states.size);\n\t\t\tstate1 = new State(this.states.size + 1);\n\t\t}\n\t\tconst transition = new Transition(symbol, state1, limitSymbol);\n\t\tstate0.addTransition(transition);\n\n\t\t// Se agregan los símbolos que abarca el rango (symbol, limitSymbol) a sigma.\n\t\tif (transition.hasLimitSymbol()) {\n\t\t\tfor (\n\t\t\t\tlet ascii = symbol.charCodeAt(0);\n\t\t\t\tascii <= limitSymbol.charCodeAt(0);\n\t\t\t\tascii++\n\t\t\t) {\n\t\t\t\tthis.sigma.add(String.fromCharCode(ascii));\n\t\t\t}\n\t\t} else {\n\t\t\tthis.sigma.add(symbol);\n\t\t}\n\n\t\t// Agregamos los estados a los conjuntos y establecemos estados inicial y finales.\n\t\tthis.states.add(state0);\n\t\tthis.states.add(state1);\n\t\tthis.startState = state0;\n\t\tthis.acceptStates.add(state1);\n\t};\n\n\t/**\n\t * Une un autómata a otro conservando la integridad de las transiciones.\n\t *\n\t * @param {Automaton} automaton {es el automata que se va a unir con this}\n\t * @memberof Automaton\n\t */\n\tpublic readonly unirAFN = (automaton: Automaton) =>{\n\t\tlet stateIni = new State(this.states.size + automaton.states.size);\n\t\tlet stateEnd = new State(this.states.size + automaton.states.size + 1); \n\n\t\tconst finalTransition = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tstateEnd\n\t\t);\n\t\tconst initialTransitionAFN_1 = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tthis.startState\n\t\t);\n\t\tconst initialTransitionAFN_2 = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tautomaton.startState\n\t\t);\n\t\t// Se agrega la transición final nueva a todos los estados finales del AFN this.\n\t\t[...this.states]\n\t\t\t.filter(state => this.acceptStates.has(state))\n\t\t\t.forEach(acceptState => {\n\t\t\t\tacceptState.addTransition(finalTransition);\n\t\t\t});\n\t\t// Se agrega la transición final nueva a todos los estados finales del AFN que recibimos como parametro.\n\t\t[...automaton.states]\n\t\t\t.filter(state => automaton.acceptStates.has(state))\n\t\t\t.forEach(acceptState => {\n\t\t\t\tacceptState.addTransition(finalTransition);\n\t\t\t});\n\t\t// Se limpia el conjunto de estados finales.\n\t\tthis.acceptStates.clear();\n\t\t// Y se reemplaza solo por el nuevo estado final.\n\t\tthis.acceptStates.add(stateEnd);\n\t\t\n\t\t//Se agregan los estados del AFN2 al AFN1\n\t\tfor(let i = 0; i < automaton.states.size; i++){\n\t\t\tthis.states.add([...automaton.states][i]);\n\t\t}\n\t\t//Se agregan los simbolos del AFN2 al AFN1\n\t\tfor(let i = 0; i < automaton.sigma.size; i++){\n\t\t\tthis.sigma.add([...automaton.sigma][i]);\n\t\t}\n\t\t// Se agregan los estados nuevos al conjunto de estados.\n\t\tthis.states.add(stateIni);\n\t\tthis.states.add(stateEnd);\n\t\t//Se reordenan los id para evitar duplicidades\n\t\tfor (let i = 0; i < this.states.size; i++) {\n\t\t\t[...this.states][i].id = i; // \"0\", \"1\", \"2\", ... \"n\"\n\t\t }\n\t\t// Se reemplaza el nuevo estado inicial.\n\t\tthis.startState = stateIni;\n\t\t// Se le agregan las transiciones al inicio antiguo del autómata y al final del mismo.\n\t\tthis.startState.addTransition(initialTransitionAFN_1);\n\t\tthis.startState.addTransition(initialTransitionAFN_2);\n\t\t// Se agregan los símbolos que abarca el rango (symbol, limitSymbol) a sigma.\n\t\t\n\t};\n\n\t/**\n\t * Crea la cerradura opcional del autómata.\n\t *\n\t * @memberof Automaton\n\t */\n\tpublic readonly makeOptional = () => {\n\t\t// Se crea el estado inicial auxiliar.\n\t\tconst nextBeginState = new State(this.states.size);\n\t\t// Se crea el estado final auxiliar.\n\t\tconst nextFinalState = new State(this.states.size + 1);\n\t\t// Se crea transición épsilon que va al estado final.\n\t\tconst finalTransition = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tnextFinalState\n\t\t);\n\t\t// Se crea transición épsilon que partirá del nuevo estado inicial.\n\t\tconst firstTransition = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tthis.startState\n\t\t);\n\t\t// Se agrega la transición final nueva a todos los estados finales.\n\t\t[...this.states]\n\t\t\t.filter(state => this.acceptStates.has(state))\n\t\t\t.forEach(acceptState => {\n\t\t\t\tacceptState.addTransition(finalTransition);\n\t\t\t});\n\t\t// Se limpia el conjunto de estados finales.\n\t\tthis.acceptStates.clear();\n\t\t// Y se reemplaza solo por el nuevo estado final.\n\t\tthis.acceptStates.add(nextFinalState);\n\t\t// Se agregan los estados nuevos al conjunto de estados.\n\t\tthis.states.add(nextBeginState);\n\t\tthis.states.add(nextFinalState);\n\t\t// Se reemplaza el nuevo estado inicial.\n\t\tthis.startState = nextBeginState;\n\t\t// Se le agregan las transiciones al inicio antiguo del autómata y al final del mismo.\n\t\tthis.startState.addTransition(firstTransition);\n\t\tthis.startState.addTransition(finalTransition);\n\t};\n\n\t/**\n\t * Crea la cerradura positiva del autómata.\n\t *\n\t * @memberof Automaton\n\t */\n\tpublic readonly makePositive = () => {\n\t\t// Nos aseguramos de que solo haya un estado final.\n\t\tif (this.acceptStates.size != 1) {\n\t\t\tconsole.log(\"El autómata no tiene un único estado final.\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Se crea el estado inicial auxiliar.\n\t\tconst nextBeginState = new State(this.states.size);\n\t\t// Se crea el estado final auxiliar.\n\t\tconst nextFinalState = new State(this.states.size + 1);\n\t\t// Se crea transición épsilon que va al estado final.\n\t\tconst finalTransition = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tnextFinalState\n\t\t);\n\t\t// Se crea transición épsilon que va hacia el viejo estado inicial.\n\t\tconst toPrevStartTransition = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\tthis.startState\n\t\t);\n\n\t\t// Agregamos transiciones a los respectivos estados.\n\t\t/* const prevFinalState = [...this.states].filter(state =>\n\t\t\tthis.acceptStates.has(state)\n\t\t)[0];*/\n\t\tconst prevFinalState = [...this.acceptStates][0];\n\t\tprevFinalState.addTransition(toPrevStartTransition);\n\t\tprevFinalState.addTransition(finalTransition);\n\n\t\tnextBeginState.addTransition(toPrevStartTransition);\n\t\tthis.acceptStates.clear();\n\t\tthis.acceptStates.add(nextFinalState);\n\t\tthis.startState = nextBeginState;\n\t\tthis.states.add(nextBeginState);\n\t\tthis.states.add(nextFinalState);\n\t};\n\n\n\t/**\n\t * Crea la cerradura de Kleene del autómata.\n\t *\n\t * @memberof Automaton\n\t */\n\tmakeKleene = () => {\n\t\t// Se hace la cerradura positiva del autómata\n\t\tthis.makePositive();\n\t\tconst transitionToEnd = new Transition(\n\t\t\tAutomaton.epsilon,\n\t\t\t[...this.acceptStates][0]\n\t\t);\n\t\t// Se agrega la transición épsilon del inicio al fin del autómata.\n\t\tthis.startState.addTransition(transitionToEnd);\n\t};\n\n\t/**\n\t * Obtiene un estado mediante el identificador suministrado. Se puede indicar si es un estado terminal.\n\t *\n\t * @private\n\t * @param {number} id {identificador del estado en this.states}\n\t * @param {boolean} [final] {bandera que indica si pertenece a this.acceptStates}\n\t * @returns {State} {estado que coincide con la consulta}\n\t * @memberof Automaton\n\t */\n\tprivate readonly getState = (id: number, final?: boolean) => {\n\t\tif (final) {\n\t\t\treturn [...this.acceptStates].filter(state => state.id === id)[0];\n\t\t}\n\t\treturn [...this.states].filter(state => state.id === id)[0];\n\t};\n\n\tpublic readonly toHTMLTable = () => {\n\t\tconst tmpSigma = new Set<string>([...this.sigma, Automaton.epsilon]);\n\t\t// Encabezado de la tabla.\n\t\tconst head =\n\t\t\t\"<tr>\" +\n\t\t\t[...tmpSigma].reduce(\n\t\t\t\t(tableHead, symbol) => tableHead + `<th>${symbol}</th>`,\n\t\t\t\t\"<th>Estado</th>\"\n\t\t\t) +\n\t\t\t\"</tr>\";\n\t\t// Cuerpo (filas) de la tabla.\n\t\tconst body = [...this.states]\n\t\t\t.map(state => {\n\t\t\t\t// Celda del estado actual.\n\t\t\t\tlet stateCell: string;\n\t\t\t\tif (this.startState === state) {\n\t\t\t\t\tstateCell = `<td class=\"state-cell start\"><p>${\n\t\t\t\t\t\tstate.id\n\t\t\t\t\t}</p></td>`;\n\t\t\t\t} else if (this.acceptStates.has(state)) {\n\t\t\t\t\tstateCell = `<td class=\"state-cell accept\"><p>${\n\t\t\t\t\t\tstate.id\n\t\t\t\t\t}</p></td>`;\n\t\t\t\t} else {\n\t\t\t\t\tstateCell = `<td class=\"state-cell\"><p>${\n\t\t\t\t\t\tstate.id\n\t\t\t\t\t}</p></td>`;\n\t\t\t\t}\n\t\t\t\t// Resto de la fila.\n\t\t\t\tlet targetStatesRow: string = \"\";\n\t\t\t\tfor (let symbol of tmpSigma) {\n\t\t\t\t\tconst targetStates = state\n\t\t\t\t\t\t.getTransitionsBySymbol(symbol)\n\t\t\t\t\t\t.map(transition => `${transition.targetState.id}`)\n\t\t\t\t\t\t.join(\", \");\n\t\t\t\t\tconst cell = `<td>{${\n\t\t\t\t\t\ttargetStates.length > 0 ? targetStates : \" \"\n\t\t\t\t\t}}</td>`;\n\t\t\t\t\ttargetStatesRow += cell;\n\t\t\t\t}\n\t\t\t\t//Fila completa.\n\t\t\t\treturn `<tr>${stateCell}${targetStatesRow}</tr>`;\n\t\t\t})\n\t\t\t// Se unen (concatenan) todas las filas\n\t\t\t.join(\"\");\n\t\treturn `<table>${head}${body}</table>`;\n\t};\n}\n\nexport default Automaton;\n","import Automaton from \"./ts/Automaton/Automaton\";\r\nconst automaton = new Automaton();\r\nconst automaton2 = new Automaton();\r\nautomaton.createBasic(\"a\", \"z\");\r\nautomaton.makeKleene();\r\nautomaton2.createBasic(\"1\", \"8\");\r\nautomaton.unirAFN(automaton2);\r\nconst containter = document.getElementById(\"automaton-table\");\r\nconst str = automaton.toHTMLTable();\r\n\r\ncontainter.innerHTML = str;\r\n\r\n","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var bundle = require('./bundle-url');\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    link.remove();\n  };\n  newLink.href = link.href.split('?')[0] + '?' + Date.now();\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nmodule.exports = reloadCSS;\n"]}