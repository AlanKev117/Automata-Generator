{"version":3,"sources":["ts/State/State.ts","ts/Transition/Transition.ts","ts/Misc/Misc.ts","ts/Automaton/Automaton.ts","ts/Listeners/ListenersHome.ts","ts/Listeners/ListenersLexic.ts","main.ts"],"names":[],"mappings":"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","file":"main.c39d6dcf.map","sourceRoot":"..","sourcesContent":["import { Transition } from \"../Transition/Transition\";\r\nclass State {\r\n\tprivate id: number;\r\n\tprivate transitions: Set<Transition>;\r\n\tprivate token: number;\r\n\t/**\r\n\t * Crea un estado.\r\n\t *\r\n\t * @param id {identidiacdor del estado}\r\n\t */\r\n\r\n\tconstructor(id: number, token?:number) {\r\n\t\tthis.id = id;\r\n\t\tthis.token = token;\r\n\t\tthis.transitions = new Set<Transition>();\r\n\t}\r\n\r\n\tpublic readonly getId = () => this.id;\r\n\tpublic getTransitions = () => this.transitions;\r\n\r\n\tpublic readonly setId = id => {\r\n\t\tthis.id = id;\r\n\t};\r\n\tpublic readonly addToken = (t : number) => {\r\n\t\tthis.token = t;\r\n\t}\r\n\t/**\r\n\t * Agrega una transición al conjunto de transiciones del estado.\r\n\t *\r\n\t * @param {Transition} t {transición a ser agregada}\r\n\t * @memberof State\r\n\t */\r\n\tpublic readonly addTransition = (t: Transition) => {\r\n\t\tthis.transitions.add(t);\r\n\t};\r\n\r\n\t/**\r\n\t * Obtiene el subconjunto del conjunto de transiciones que tengan el símbolo symbol.\r\n\t *\r\n\t * @param {string} symbol {símbolo con el que se hace la transición}\r\n\t * @memberof State\r\n\t */\r\n\tpublic getTransitionsBySymbol = (symbol: string) => {\r\n\t\treturn [...this.transitions].filter(transition => {\r\n\t\t\tif (transition.hasLimitSymbol()) {\r\n\t\t\t\treturn symbol.length === 1\r\n\t\t\t\t\t? transition.getSymbol() <= symbol &&\r\n\t\t\t\t\t\t\tsymbol <= transition.getLimitSymbol()\r\n\t\t\t\t\t: false;\r\n\t\t\t} else {\r\n\t\t\t\treturn transition.getSymbol() === symbol;\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\r\n}\r\n\r\nexport { State };\r\n","import { State } from \"../State/State\";\r\n\r\nclass Transition {\r\n\tprivate symbol: string;\r\n\tprivate limitSymbol: string;\r\n\tprivate targetState: State;\r\n\r\n\tconstructor(symbol: string, targetState: State, limitSymbol?: string) {\r\n\t\t// Se establece el símbolo límite (para rangos), si existe.\r\n\t\tif (limitSymbol) {\r\n\t\t\tif (symbol.length != 1 || limitSymbol.length != 1) {\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t\"La longitud de ambos símbolos para un rango debe ser 1\"\r\n\t\t\t\t);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tif (limitSymbol.charCodeAt(0) <= symbol.charCodeAt(0)) {\r\n\t\t\t\tconsole.log(\"No es posible crear la transición con ese rango.\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tthis.limitSymbol = limitSymbol;\r\n\t\t} else {\r\n\t\t\tthis.limitSymbol = null;\r\n\t\t}\r\n\t\t// Se agrega el símbolo principal de la transición.\r\n\t\tthis.symbol = symbol;\r\n\t\t// Se establece el estado objetivo.\r\n\t\tthis.targetState = targetState;\r\n\t}\r\n\r\n\tpublic readonly getSymbol = () => this.symbol;\r\n\tpublic readonly getLimitSymbol = () => this.limitSymbol;\r\n\tpublic readonly getTargetState = () => this.targetState;\r\n\r\n\thasLimitSymbol = () => {\r\n\t\treturn this.limitSymbol ? true : false;\r\n\t};\r\n}\r\nexport { Transition };\r\n","import { Automaton } from \"../Automaton/Automaton\";\r\nimport { State } from \"../State/State\";\r\nimport { Transition } from \"../Transition/Transition\";\r\nimport { Queue } from \"../Queue/Queue\";\r\n\r\nnamespace Misc {\r\n    export const EPSILON: string = \"\\u03B5\";\r\n\r\n    /**\r\n     * Función Ir_a(). Aplica la función Mover() con los parámetros\r\n     * \"states\" que es un conjunto de estados y \"symbol\" que es un\r\n     * símbolo. Al resultado se le\r\n     *\r\n     *\r\n     * @param {Set<State>} states\r\n     * @param {string} symbol\r\n     * @returns {Set<State>}\r\n     */\r\n    export const goTo = (states: Set<State>, symbol: string) => {\r\n        return epsilonClosure(move(states, symbol));\r\n    };\r\n\r\n    /**\r\n     * Función Mover(). Obtiene el conjunto de estados al que se\r\n     * puede acceder desde otro conjunto de estados \"states\"\r\n     * estrictamente mediante transiciones con un símbolo \"symbol\"\r\n     * dado.\r\n     *\r\n     * @param {Set<State>} setOfStates\r\n     * @param {string} symbol\r\n     * @returns {Set<State>}\r\n     */\r\n    export const move = (states: Set<State>, symbol: string) => {\r\n        const result = [...states].map(state => simpleMove(state, symbol));\r\n        return result.reduce((union, set) => {\r\n            set.forEach(state => {\r\n                union.add(state);\r\n            });\r\n            return union;\r\n        }, new Set<State>());\r\n    };\r\n\r\n    const simpleMove = (state: State, symbol: string) => {\r\n        return new Set<State>(\r\n            [...state.getTransitions().values()]\r\n                .filter(transition => transition.getSymbol() === symbol)\r\n                .map(transition => transition.getTargetState())\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Obtiene la cerradura épsilon de un conjunto de estados.\r\n     *\r\n     * @param {Set<State>} states\r\n     * @returns {Set<State>}\r\n     */\r\n    export const epsilonClosure = (states: Set<State>) => {\r\n        const epsilonSets = [...states].map(state =>\r\n            simpleEpsilonClosure(state)\r\n        );\r\n        return epsilonSets.reduce((union, set) => {\r\n            set.forEach(state => {\r\n                union.add(state);\r\n            });\r\n            return union;\r\n        }, new Set<State>());\r\n    };\r\n\r\n    /**\r\n     * Obtiene la cerradura épsilon de un estado a un nivel.\r\n     *\r\n     * @param {State} state\r\n     * @returns {Set<State>}\r\n     */\r\n    const simpleEpsilonClosure = (state: State) => {\r\n        // Función auxiliar.\r\n        const epsilonChildren = (s: State) => {\r\n            return [...s.getTransitions()]\r\n                .filter(transition => transition.getSymbol() === Misc.EPSILON)\r\n                .map(transition => transition.getTargetState());\r\n        };\r\n        // Agregamos estados hasta que no se puedan agregar más.\r\n        let previousSize: number;\r\n        const epStates = new Set<State>();\r\n        let children = [state];\r\n        do {\r\n            previousSize = epStates.size;\r\n            children.forEach(child => {\r\n                epStates.add(child);\r\n            });\r\n            children = children.reduce((union, current) => {\r\n                const newChildren = epsilonChildren(current);\r\n                newChildren.forEach(newChild => {\r\n                    union.push(newChild);\r\n                });\r\n                return union;\r\n            }, []);\r\n        } while (previousSize !== epStates.size);\r\n\r\n        return epStates;\r\n    };\r\n\r\n    /**\r\n     *Realiza la conversion de AFN  a AFD\r\n     *\r\n     * @param {Automaton} afn\r\n     * @returns {Automaton} afd\r\n     */\r\n\r\n    export const afnToAfd = (afn: Automaton) => {\r\n        //let queue = new Queue();\r\n        let afd = new Automaton(afn.getName());\r\n        let estadoInicial = new State(0);\r\n        let resultado = new Set<State>();\r\n        let estadoAProcesar = new Set<State>();\r\n        let estados = new Set<Set<State>>(); //Es un conjunto de conjuntos de estados\r\n        let estadosAFD = new Set<State>(); //Contendra estados numerados de 0 a n\r\n        let transicion: Transition;\r\n        let state: State;\r\n        let queueA: Array<Set<State>>;\r\n        queueA = new Array<Set<State>>();\r\n        queueA = [];\r\n        estados.clear();\r\n        afd.sigma = afn.getSigma(); //Se copia el alfabeto del AFN al AFD\r\n        afd.sigma.delete(Misc.EPSILON); //Elimina Epsilon del alfabeto del AFD\r\n        resultado = simpleEpsilonClosure(afn.startState); //Se calcula la cerradura epsilon del estado inicial y se guarda en resultado\r\n        //queue.queue(resultado);\r\n        console.log(\"La cola empieza con: \" + queueA.length);\r\n        queueA.push(resultado);\r\n        console.log(resultado.size);\r\n        estados.add(resultado);\r\n        afd.states.add(estadoInicial); //Agrega el inicial\r\n        afd.startState = estadoInicial;\r\n        while (queueA.length != 0) {\r\n\t\t\testadoAProcesar.clear();\r\n            estadoAProcesar = queueA.shift(); //Desencola\r\n            estados.add(estadoAProcesar); //Se agrega al subconjunto de estados al conjunto estados\r\n\t\t\t\r\n\t\t\tfor (let i = 0; i < afn.sigma.size; i++) {\r\n\t\t\t\t//Se itera sobre los simbolos del alfabeto\r\n\t\t\t\tresultado.clear();\r\n                resultado = goTo(estadoAProcesar, [...afn.sigma][i]);\r\n                console.log(\"Resultado.size = \" + resultado.size + \" resultado = \" + resultado.entries());\r\n                state = new State(estadosAFD.size);\r\n                afd.states.add(state);\r\n                if (!estados.has(resultado)) {\r\n                    //Si no exisitia este subconjunto de estados va a conformar un nuevo estado del AFD con su transicion\r\n                    transicion = new Transition([...afn.sigma][i], state);\r\n                    for (let j = 0; j < estadoAProcesar.size; j++) {\r\n                        if (afn.acceptStates.has([...estadoAProcesar][j])) {\r\n                            //Si ese set contenia al menos un estado de aceptacion\r\n                            afd.acceptStates.add(state); //se establece state como estado de aceptacion del AFD\r\n                        }\r\n                    }\r\n                    afd.startState.addTransition(transicion);\r\n                    /**\r\n                     * ESTA ES LA PARTE QUE ESTA DANDO PROBLEMAS, SIN EMBARGO ES FUNDAMENTAL PARA EL ALGORITMO\r\n                     * PORQUE ES LO QUE MANTIENE ACTUALIZADO EL ARREGLO ESTADOS CON LOS ESTADOS YA VISTOS\r\n                     * (YA PROBE SIMPLEMENTE IR AGREGANDO LOS ESTADOS YA VISTOS A ESTADOS CSIN LA COLA PERO\r\n                     * TAMPOCO FUNCIONA)\r\n                     */\r\n                    if(resultado.size != 0){\r\n\t\t\t\t\t\tqueueA.push(resultado);\r\n\t\t\t\t\t\tconsole.log(\"Tamano de cola: \" + queueA.length);\r\n\t\t\t\t\t}\r\n\t\t\t\t} \r\n\t\t\t\telse {\r\n                    console.log(\"estado ya existente\");\r\n                    transicion = new Transition(\r\n                        [...afn.sigma][i],\r\n                        [...afd.states][[...estados].indexOf(resultado)] //Agrega una transicion al estado repetido\r\n                    );\r\n                    state.addTransition(transicion); //Agrega una transicion al estado j del AFD\r\n\t\t\t\t}\r\n            }\r\n        }\r\n        console.log(\"El proceso termino\");\r\n        console.log(\"El AFD quedo con \" + afd.states.size + \"estados\");\r\n        console.log(\r\n            \"El AFD tiene \" + afd.acceptStates.size + \" estados de aceptacion\"\r\n        );\r\n        const newStates = [...afd.states];\r\n        newStates.forEach((state, index) => {\r\n            state.setId(index);\r\n        });\r\n        return afd;\r\n    };\r\n\r\n    export /**\r\n     *\r\n     *\r\n     * @param {string} symbol\r\n     * @param {string} limitSymbol\r\n     * @returns\r\n     */\r\n    const getSymbolsFromRange = (symbol: string, limitSymbol: string) => {\r\n        if (symbol.length !== 1 || limitSymbol.length !== 1) {\r\n            return null;\r\n        }\r\n        const begin = symbol.charCodeAt(0);\r\n        const end = limitSymbol.charCodeAt(0);\r\n        const symbols: string[] = [];\r\n        for (let ascii = begin; ascii <= end; ascii++) {\r\n            symbols.push(String.fromCharCode(ascii));\r\n        }\r\n        return symbols;\r\n    };\r\n\r\n    /**\r\n     * Para el análisis léxico, tomamos el último estado de aceptación\r\n     * con el que se obtuvo un token y se guarda el índice hasta que, con\r\n     * caracteres siguientes, no se pueda hacer otra transición.\r\n     *\r\n     * En ese momento, se corta la cadena hasta el índice con el que se tuvo el\r\n     * último token y se empieza el proceso de nuevo.\r\n     *\r\n     *\r\n     * LIBRO: Compiler design in C.\r\n     */\r\n\r\n/*     const analizadorLexico = (A:Automaton) =>{\r\n\t\tvar estadoActual = A.startState;\r\n\t\tpreviously_seen_accepting = false; //Anteriormente hemos estado en aceptacion = no\r\n\t\t\r\n\t\tif(esUltimaEntrada(caracter_sig)){ //El caracter siguiente es la ultima entrada?\r\n    \t\treturn 0;//Termina el algoritmo\r\n    \t}\r\n    \twhile (!esUltimaEntrada(caracter_sig)){ //mientras el caracter siguiente  no sea la ultima entrada\r\n\r\n    \t\tif(estadoActual.haytrancicion(caracter_sig)){ // Si hay una transición ern el estado actual con el siguiente caracter\r\n    \t\t\testadoActual = estadoActual.transicion(caracter_sig);\r\n    \t\t\tif(estadoActual == acceptState){\r\n    \t\t\t\tposicionActual = pocicionEntrada\r\n    \t\t\t}else\r\n\r\n    \t\t}\r\n\r\n    \t}\r\n\r\n    } */\r\n}\r\n\r\nexport default Misc;\r\n","import { State } from \"../State/State\";\r\nimport { Transition } from \"../Transition/Transition\";\r\nimport Misc from \"../Misc/Misc\";\r\n\r\nclass Automaton {\r\n    private static tok = 0;\r\n    /**\r\n     * Nombre que se le asignará al autómata cuando se cree.\r\n     *\r\n     * @private\r\n     * @type {string}\r\n     * @memberof Automaton\r\n     */\r\n    private name: string;\r\n\r\n    /**\r\n     * Alfabeto del autómata.\r\n     *\r\n     * @private\r\n     * @type {Set<string>}\r\n     * @memberof Automaton\r\n     */\r\n    public sigma: Set<string>;\r\n\r\n    /**\r\n     * Conjunto de estados del autómata.\r\n     *\r\n     * @private\r\n     * @type {Set<State>}\r\n     * @memberof Automaton\r\n     */\r\n    public states: Set<State>;\r\n\r\n    /**\r\n     * Estado inicial del autómata.\r\n     *\r\n     * @private\r\n     * @type {State}\r\n     * @memberof Automaton\r\n     */\r\n    public startState: State;\r\n\r\n    /**\r\n     * Conjunto de estados de aceptación del autómata.\r\n     *\r\n     * @private\r\n     * @type {Set<State>}\r\n     * @memberof Automaton\r\n     */\r\n    public acceptStates: Set<State>;\r\n\r\n    /**\r\n     * Genera un autómata vacío.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    constructor(name: string) {\r\n        this.sigma = new Set<string>();\r\n        this.sigma.clear();\r\n        this.states = new Set<State>();\r\n        this.states.clear();\r\n        this.startState = null;\r\n        this.acceptStates = new Set<State>();\r\n        this.acceptStates.clear();\r\n        this.name = name;\r\n    }\r\n\r\n    public readonly getName = () => this.name;\r\n    public readonly getSigma = () => this.sigma;\r\n    public readonly getStates = () => this.states;\r\n    public readonly getStartState = () => this.startState;\r\n    public readonly getAcceptStates = () => this.acceptStates;\r\n\r\n    /**\r\n     * Crea un autómata básico de una transición con el símbolo symbol.\r\n     *\r\n     * @param {string} symbol {es el símbolo con el que se genera la transición}\r\n     * @param {string} [limitSymbol] {es un símbolo opcional que delimita el rango [symbol, limitSymbol]}\r\n     * @memberof Automaton\r\n     */\r\n    public readonly createBasic = (symbol: string, limitSymbol?: string) => {\r\n        let state0, state1;\r\n        if (this.states.size == 0) {\r\n            state0 = new State(0);\r\n            state1 = new State(1);\r\n        } else {\r\n            state0 = new State(this.states.size);\r\n            state1 = new State(this.states.size + 1);\r\n        }\r\n        const transition = new Transition(symbol, state1, limitSymbol);\r\n        state0.addTransition(transition);\r\n\r\n        // Se agregan los símbolos que abarca el rango (symbol, limitSymbol) a sigma.\r\n        if (transition.hasLimitSymbol()) {\r\n            const symbols = Misc.getSymbolsFromRange(symbol, limitSymbol);\r\n            symbols.forEach(symbol => {\r\n                this.sigma.add(symbol);\r\n            });\r\n        } else {\r\n            this.sigma.add(symbol);\r\n        }\r\n\r\n        // Agregamos los estados a los conjuntos y establecemos estados inicial y finales.\r\n        this.states.add(state0);\r\n        this.states.add(state1);\r\n        this.startState = state0;\r\n        this.acceptStates.add(state1);\r\n        //Agregamos un token multiplo de 10  a cada uno de los estados de aceptación de nuestros automatas\r\n        //[...this.acceptStates].forEach(acceptState => acceptState.addToken(Automaton.tok+10))\r\n    };\r\n\r\n    /**\r\n     * Une un autómata a otro conservando la integridad de las transiciones.\r\n     * Guarda la unión mutando al autómata this.\r\n     *\r\n     * @param {Automaton} automaton {es el automata que se va a unir con this}\r\n     * @memberof Automaton\r\n     */\r\n    public readonly unirAFN = (automaton: Automaton) => {\r\n        let stateIni = new State(this.states.size + automaton.states.size);\r\n        let stateEnd = new State(this.states.size + automaton.states.size + 1);\r\n\r\n        const finalTransition = new Transition(Misc.EPSILON, stateEnd);\r\n        const initialTransitionAFN_1 = new Transition(\r\n            Misc.EPSILON,\r\n            this.startState\r\n        );\r\n        const initialTransitionAFN_2 = new Transition(\r\n            Misc.EPSILON,\r\n            automaton.startState\r\n        );\r\n        // Se agrega la transición final nueva a todos los estados finales del AFN this.\r\n        [...this.acceptStates].forEach(acceptState => {\r\n            acceptState.addTransition(finalTransition);\r\n        });\r\n        // Se agrega la transición final nueva a todos los estados finales del AFN que recibimos como parametro.\r\n        [...automaton.acceptStates].forEach(acceptState => {\r\n            acceptState.addTransition(finalTransition);\r\n        });\r\n        // Se limpia el conjunto de estados finales.\r\n        this.acceptStates.clear();\r\n        // Y se reemplaza solo por el nuevo estado final.\r\n        this.acceptStates.add(stateEnd);\r\n\r\n        // Reasignamos id a estados del autómata argumento y los agregamos al\r\n        // conjunto de estados de autómata this.\r\n        const newStates = [...automaton.states];\r\n        newStates.forEach((state, index) => {\r\n            state.setId(this.states.size + index);\r\n        });\r\n        newStates.forEach(state => {\r\n            this.states.add(state);\r\n        });\r\n\r\n        //Se agregan los simbolos del AFN2 al AFN1\r\n        [...automaton.sigma].forEach(symbol => {\r\n            this.sigma.add(symbol);\r\n        });\r\n        // Se agregan los estados nuevos al conjunto de estados.\r\n        this.states.add(stateIni);\r\n        this.states.add(stateEnd);\r\n\r\n        // Se reemplaza el nuevo estado inicial.\r\n        this.startState = stateIni;\r\n        // Se le agregan las transiciones al inicio antiguo del autómata y al final del mismo.\r\n        this.startState.addTransition(initialTransitionAFN_1);\r\n        this.startState.addTransition(initialTransitionAFN_2);\r\n        // Se agregan los símbolos que abarca el rango (symbol, limitSymbol) a sigma.\r\n    };\r\n\r\n    /**\r\n     * Concatena un automata con otro para analisis lexico (teniendo 2 o mas estados\r\n     * de aceptacion y conservandolos)\r\n     * \r\n     * @param {Automaton} automaton {es el automata que se va a unir con this}\r\n     * @memberof Automaton\r\n     */\r\n\r\n    public readonly unirAFNAnalisis = (automaton: Automaton) => {\r\n        let stateIni = new State(0);\r\n        const initialTransitionAFN_1 = new Transition(\r\n            Misc.EPSILON,\r\n            this.startState\r\n        );\r\n        const initialTransitionAFN_2 = new Transition(\r\n            Misc.EPSILON,\r\n            automaton.startState\r\n        );\r\n\r\n        // Reasignamos id a estados del autómata argumento y los agregamos al\r\n        // conjunto de estados de autómata this.\r\n        const newStates = [...automaton.states];\r\n        newStates.forEach((state, index) => {\r\n            state.setId(this.states.size + index);\r\n        });\r\n        newStates.forEach(state => {\r\n            this.states.add(state);\r\n        });\r\n\r\n        //Se agregan los simbolos del AFN2 al AFN1\r\n        [...automaton.sigma].forEach(symbol => {\r\n            this.sigma.add(symbol);\r\n        });\r\n        // Se agregan los estados nuevos al conjunto de estados.\r\n        this.states.add(stateIni);\r\n                // Se reemplaza el nuevo estado inicial.\r\n        this.startState = stateIni;\r\n        // Se le agregan las transiciones al inicio antiguo del autómata y al final del mismo.\r\n        this.startState.addTransition(initialTransitionAFN_1);\r\n        this.startState.addTransition(initialTransitionAFN_2);\r\n    }\r\n\r\n    /**\r\n     * Concatena al autómata mismo con un automata \"autómaton\" dado y guarda\r\n     * el resultado mutando el autómata this.\r\n     *\r\n     * @param {Automaton} automaton\r\n     * @memberof Automaton\r\n     */\r\n    public readonly concatenarAFN = (automaton: Automaton) => {\r\n        // Capturamos los estados de automaton excluyendo el inicial.\r\n        const incomingStates = [...automaton.getStates()].filter(\r\n            state => state !== automaton.startState\r\n        );\r\n\r\n        // Re-indexamos los id's de esos estados.\r\n        incomingStates.forEach((state, index) => {\r\n            state.setId(this.states.size + index);\r\n        });\r\n\r\n        //Agregamos las transiciones del estado inicial de automaton al final de this.\r\n        [...automaton.startState.getTransitions()].forEach(transition => {\r\n            [...this.acceptStates][0].addTransition(transition);\r\n        });\r\n\r\n        for (let i = 0; i < automaton.sigma.size; i++) {\r\n            this.sigma.add([...automaton.sigma][i]);\r\n        }\r\n\r\n        incomingStates.forEach(state => {\r\n            this.states.add(state);\r\n        });\r\n\r\n        this.acceptStates.clear();\r\n        this.acceptStates.add([...automaton.acceptStates][0]);\r\n    };\r\n    /**\r\n     * Hace opcional al autómata.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    public readonly makeOptional = () => {\r\n        // Se crea el estado inicial auxiliar.\r\n        const nextBeginState = new State(this.states.size);\r\n        // Se crea el estado final auxiliar.\r\n        const nextFinalState = new State(this.states.size + 1);\r\n        // Se crea transición épsilon que va al estado final.\r\n        const finalTransition = new Transition(Misc.EPSILON, nextFinalState);\r\n        // Se crea transición épsilon que partirá del nuevo estado inicial.\r\n        const firstTransition = new Transition(Misc.EPSILON, this.startState);\r\n        // Se agrega la transición final nueva a todos los estados finales.\r\n        [...this.states]\r\n            .filter(state => this.acceptStates.has(state))\r\n            .forEach(acceptState => {\r\n                acceptState.addTransition(finalTransition);\r\n            });\r\n        // Se limpia el conjunto de estados finales.\r\n        this.acceptStates.clear();\r\n        // Y se reemplaza solo por el nuevo estado final.\r\n        this.acceptStates.add(nextFinalState);\r\n        // Se agregan los estados nuevos al conjunto de estados.\r\n        this.states.add(nextBeginState);\r\n        this.states.add(nextFinalState);\r\n        // Se reemplaza el nuevo estado inicial.\r\n        this.startState = nextBeginState;\r\n        // Se le agregan las transiciones al inicio antiguo del autómata y al final del mismo.\r\n        this.startState.addTransition(firstTransition);\r\n        this.startState.addTransition(finalTransition);\r\n    };\r\n\r\n    /**\r\n     * Hace positivo al autómata.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    public readonly makePositive = () => {\r\n        // Nos aseguramos de que solo haya un estado final.\r\n        if (this.acceptStates.size != 1) {\r\n            console.log(\"El autómata no tiene un único estado final.\");\r\n            return;\r\n        }\r\n\r\n        // Se crea el estado inicial auxiliar.\r\n        const nextBeginState = new State(this.states.size);\r\n        // Se crea el estado final auxiliar.\r\n        const nextFinalState = new State(this.states.size + 1);\r\n        // Se crea transición épsilon que va al estado final.\r\n        const finalTransition = new Transition(Misc.EPSILON, nextFinalState);\r\n        // Se crea transición épsilon que va hacia el viejo estado inicial.\r\n        const toPrevStartTransition = new Transition(\r\n            Misc.EPSILON,\r\n            this.startState\r\n        );\r\n\r\n        // Agregamos transiciones a los respectivos estados.\r\n        const prevFinalState = [...this.acceptStates][0];\r\n        prevFinalState.addTransition(toPrevStartTransition);\r\n        prevFinalState.addTransition(finalTransition);\r\n\r\n        nextBeginState.addTransition(toPrevStartTransition);\r\n        this.acceptStates.clear();\r\n        this.acceptStates.add(nextFinalState);\r\n        this.startState = nextBeginState;\r\n        this.states.add(nextBeginState);\r\n        this.states.add(nextFinalState);\r\n    };\r\n\r\n    /**\r\n     * Hace Kleene al autómata.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    public readonly makeKleene = () => {\r\n        // Se hace la cerradura positiva del autómata\r\n        this.makePositive();\r\n        const transitionToEnd = new Transition(\r\n            Misc.EPSILON,\r\n            [...this.acceptStates][0]\r\n        );\r\n        // Se agrega la transición épsilon del inicio al fin del autómata.\r\n        this.startState.addTransition(transitionToEnd);\r\n    };\r\n\r\n    /**\r\n     * Crea una copia exacta de sí mismo sin ninguna depndencia en referencias.\r\n     *\r\n     * @memberof Automaton\r\n     * @returns {Automaton}\r\n     */\r\n    public readonly copy = () => {\r\n        // Creamos un autómata con el mismo nombre.\r\n        const copy = new Automaton(this.name);\r\n\r\n        // Creamos estados y transiciones así como el sigma del nuevo autómata según corresponda.\r\n        [...this.getStates()].forEach(state => {\r\n            [...state.getTransitions()].forEach(transition => {\r\n                copy.createTransition(\r\n                    state.getId(),\r\n                    transition.getSymbol(),\r\n                    transition.getLimitSymbol(),\r\n                    transition.getTargetState().getId()\r\n                );\r\n            });\r\n        });\r\n        // Indicamos cuál estado del nuevo autómata es el inicial.\r\n        copy.startState = [...copy.getStates()].find(\r\n            state => state.getId() === this.getStartState().getId()\r\n        );\r\n        // Indicamos cuáles estados del nuevo autómata son de aceptación.\r\n        [...this.getAcceptStates()].forEach(acceptState => {\r\n            copy.getAcceptStates().add(\r\n                [...copy.getStates()].find(\r\n                    state => state.getId() === acceptState.getId()\r\n                )\r\n            );\r\n        });\r\n\r\n        return copy;\r\n    };\r\n\r\n    /**\r\n     * Método para crear una transición de un estado de origen a unodestino con un símbolo o\r\n     * un rango de símbolos.\r\n     *\r\n     * Si los identificadores no corresponden a algúno de los estados del conjunto de\r\n     * estados del autómata, se creará.\r\n     *\r\n     * Helper para Automaton.copy()\r\n     *\r\n     * @private\r\n     * @param {number} originStateID\r\n     * @param {string} symbol\r\n     * @param {string} limitSymbol\r\n     * @param {number} targetStateID\r\n     * @memberof Automaton\r\n     */\r\n    public createTransition = (\r\n        originStateID: number,\r\n        symbol: string,\r\n        limitSymbol: string,\r\n        targetStateID: number\r\n    ) => {\r\n        let originState = [...this.states].find(\r\n            state => state.getId() === originStateID\r\n        );\r\n        let targetState = [...this.states].find(\r\n            state => state.getId() === targetStateID\r\n        );\r\n        if (!originState) {\r\n            originState = new State(originStateID);\r\n            this.states.add(originState);\r\n        }\r\n\r\n        if (!targetState) {\r\n            targetState = new State(targetStateID);\r\n            this.states.add(targetState);\r\n        }\r\n        const transition = new Transition(symbol, targetState, limitSymbol);\r\n        originState.addTransition(transition);\r\n\r\n        if (transition.hasLimitSymbol()) {\r\n            const symbols = Misc.getSymbolsFromRange(symbol, limitSymbol);\r\n            symbols.forEach(symbol => {\r\n                this.sigma.add(symbol);\r\n            });\r\n        } else {\r\n            this.sigma.add(symbol);\r\n        }\r\n    };\r\n\r\n    public readonly esAFD = () => {\r\n        const symbols = new Set<string>();\r\n        [...this.states].forEach(state => {\r\n            symbols.clear();\r\n            [...state.getTransitions()].forEach(trans => {\r\n                const tranSymbols = trans.hasLimitSymbol()\r\n                    ? Misc.getSymbolsFromRange(\r\n                          trans.getSymbol(),\r\n                          trans.getLimitSymbol()\r\n                      )\r\n                    : [trans.getSymbol()];\r\n                tranSymbols.forEach(tranSymbol => {\r\n                    if (\r\n                        symbols.has(tranSymbol) ||\r\n                        tranSymbol === Misc.EPSILON\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        return true;\r\n    };\r\n\r\n    public readonly toHTMLTable = () => {\r\n        const tmpSigma = new Set<string>([...this.sigma, Misc.EPSILON]);\r\n        // Encabezado de la tabla.\r\n        const head =\r\n            \"<tr>\" +\r\n            [...tmpSigma].reduce(\r\n                (tableHead, symbol) => tableHead + `<th>${symbol}</th>`,\r\n                \"<th>Estado</th>\"\r\n            ) +\r\n            \"</tr>\";\r\n        // Cuerpo (filas) de la tabla.\r\n        const body = [...this.states]\r\n            .map(state => {\r\n                // Celda del estado actual.\r\n                let stateCell: string;\r\n                if (this.startState === state) {\r\n                    stateCell = `<td class=\"state-cell start\"><p>${state.getId()}</p></td>`;\r\n                } else if (this.acceptStates.has(state)) {\r\n                    stateCell = `<td class=\"state-cell accept\"><p>${state.getId()}</p></td>`;\r\n                } else {\r\n                    stateCell = `<td class=\"state-cell\"><p>${state.getId()}</p></td>`;\r\n                }\r\n                // Resto de la fila.\r\n                let targetStatesRow: string = \"\";\r\n                for (let symbol of tmpSigma) {\r\n                    const targetStates = state\r\n                        .getTransitionsBySymbol(symbol)\r\n                        .map(\r\n                            transition =>\r\n                                `${transition.getTargetState().getId()}`\r\n                        )\r\n                        .join(\", \");\r\n                    const cell = `<td>{${\r\n                        targetStates.length > 0 ? targetStates : \" \"\r\n                    }}</td>`;\r\n                    targetStatesRow += cell;\r\n                }\r\n                //Fila completa.\r\n                return `<tr>${stateCell}${targetStatesRow}</tr>`;\r\n            })\r\n            // Se unen (concatenan) todas las filas\r\n            .join(\"\");\r\n        return `<table>${head}${body}</table>`;\r\n    };\r\n}\r\n\r\nexport { Automaton };\r\n","import { Automaton } from \"../Automaton/Automaton\";\r\nimport Misc from \"../Misc/Misc\";\r\n\r\nnamespace ListenersHome {\r\n\t// Inicializador para el DOM\r\n\t// Desactivamos las secciones que no se deben visualizar.\r\n\texport const init = \r\n\t() => {\r\n\t\t(<HTMLElement>document.querySelector(\"#tools\")).style.display = \"none\";\r\n\t\t(<HTMLElement>document.querySelector(\"#target\")).style.display = \"none\";\r\n\t\t(<HTMLElement>document.querySelector(\"#main__lexic\")).style.display =\r\n\t\t\t\"none\";\r\n\t};\r\n\t// Listener para crear autómatas simples\r\n\texport const activateBtnCreator = (automata: Automaton[]) => {\r\n\t\tdocument.querySelector(\".btn-creator\").addEventListener(\"click\", () => {\r\n\t\t\tconst name_element = <HTMLInputElement>(\r\n\t\t\t\tdocument.querySelector(\"#name\")\r\n\t\t\t);\r\n\t\t\tconst symbol_element = <HTMLInputElement>(\r\n\t\t\t\tdocument.querySelector(\"#symbol\")\r\n\t\t\t);\r\n\t\t\tconst name = name_element.value;\r\n\t\t\tif (name.length === 0) {\r\n\t\t\t\talert(\"Debe ingresar un nombre para el autómata.\");\r\n\t\t\t\treturn;\r\n\t\t\t} else if (\r\n\t\t\t\tautomata.find(automaton => automaton.getName() === name)\r\n\t\t\t) {\r\n\t\t\t\talert(\"Ingrese otro nombre para el autómata.\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tconst symbol = symbol_element.value;\r\n\t\t\tconst symbols = symbol.split(\"-\");\r\n\t\t\tswitch (symbols.length) {\r\n\t\t\t\tcase 1: {\r\n\t\t\t\t\tconst automaton = new Automaton(name);\r\n\t\t\t\t\tautomaton.createBasic(symbols[0]);\r\n\t\t\t\t\tautomata.push(automaton);\r\n\t\t\t\t\t//console.log(Misc.goTo(automaton.getStates(), \"a\"));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcase 2: {\r\n\t\t\t\t\tif (symbols.find(_symbol => _symbol.length !== 1)) {\r\n\t\t\t\t\t\talert(\r\n\t\t\t\t\t\t\t\"El rango se da solamente con símbolos de longitud 1\"\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst automaton = new Automaton(name);\r\n\t\t\t\t\tautomaton.createBasic(symbols[0], symbols[1]);\r\n\t\t\t\t\tautomata.push(automaton);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdefault: {\r\n\t\t\t\t\talert(\"Inserte un símbolo o rango adecuado.\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconst option_one = document.createElement(\"option\");\r\n\t\t\toption_one.text = name;\r\n\t\t\toption_one.value = name;\r\n\t\t\tconst option_two = document.createElement(\"option\");\r\n\t\t\toption_two.text = name;\r\n\t\t\toption_two.value = name;\r\n\t\t\tconst automaton_select = <HTMLSelectElement>(\r\n\t\t\t\tdocument.querySelector(\"#automaton\")\r\n\t\t\t);\r\n\t\t\tconst target_select = <HTMLSelectElement>(\r\n\t\t\t\tdocument.querySelector(\"#target-automaton\")\r\n\t\t\t);\r\n\t\t\tautomaton_select.appendChild(option_one);\r\n\t\t\tautomaton_select.value = name;\r\n\t\t\ttarget_select.appendChild(option_two);\r\n\t\t\tname_element.value = \"\";\r\n\t\t\tsymbol_element.value = \"\";\r\n\t\t});\r\n\t};\r\n\r\n\t// Listeners para mostrar tabla de autómata según se seleccione.\r\n\texport const activateAutomatonSelector = (automata: Automaton[]) => {\r\n\t\tdocument\r\n\t\t\t.querySelector(\"#automaton\")\r\n\t\t\t.addEventListener(\"DOMNodeInserted\", event => {\r\n\t\t\t\tconst selector = <HTMLSelectElement>event.target;\r\n\t\t\t\tif (selector.childElementCount !== 0) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tdocument.querySelector(\r\n\t\t\t\t\t\"#automaton-table\"\r\n\t\t\t\t).innerHTML = automata\r\n\t\t\t\t\t.find(automaton => automaton.getName() === selector.value)\r\n\t\t\t\t\t.toHTMLTable();\r\n\t\t\t\t(<HTMLElement>document.querySelector(\"#tools\")).style.display =\r\n\t\t\t\t\t\"inline-block\";\r\n\t\t\t});\r\n\t\tdocument\r\n\t\t\t.querySelector(\"#automaton\")\r\n\t\t\t.addEventListener(\"change\", event => {\r\n\t\t\t\tconst name = (<HTMLSelectElement>event.target).value;\r\n\t\t\t\tdocument.querySelector(\r\n\t\t\t\t\t\"#automaton-table\"\r\n\t\t\t\t).innerHTML = automata\r\n\t\t\t\t\t.find(automaton => automaton.getName() === name)\r\n\t\t\t\t\t.toHTMLTable();\r\n\t\t\t});\r\n\t};\r\n\r\n\t// Listeners para controlar comportamiento de sección \"target\".\r\n\texport const makeTargetAutomatonSelectorDynamic = (\r\n\t\tautomata: Automaton[]\r\n\t) => {\r\n\t\tdocument\r\n\t\t\t.querySelector(\"#operation\")\r\n\t\t\t.addEventListener(\"change\", event => {\r\n\t\t\t\tconst operation = (<HTMLSelectElement>event.target).value;\r\n\t\t\t\tif (operation === \"unirAFN\" || operation === \"concatenarAFN\") {\r\n\t\t\t\t\t(<HTMLElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\"#target\")\r\n\t\t\t\t\t)).style.display = \"inline-block\";\r\n\t\t\t\t\t(<HTMLButtonElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\".btn-execute__one\")\r\n\t\t\t\t\t)).style.display = \"none\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\t(<HTMLElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\"#target\")\r\n\t\t\t\t\t)).style.display = \"none\";\r\n\t\t\t\t\t(<HTMLButtonElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\".btn-execute__one\")\r\n\t\t\t\t\t)).style.display = \"initial\";\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t};\r\n\r\n\t// Listeners para realizar las operaciones unarias.\r\n\texport const activateBtnExecuteOne = (automata: Automaton[]) => {\r\n\t\tdocument\r\n\t\t\t.querySelector(\".btn-execute__one\")\r\n\t\t\t.addEventListener(\"click\", () => {\r\n\t\t\t\t// Obtenemos el valor del selector.\r\n\t\t\t\tconst operation = (<HTMLSelectElement>(\r\n\t\t\t\t\tdocument.querySelector(\"#operation\")\r\n\t\t\t\t)).value;\r\n\r\n\t\t\t\t// Buscamos el autómata.\r\n\t\t\t\tlet automaton = automata.find(a => {\r\n\t\t\t\t\tconst name = (<HTMLSelectElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\"#automaton\")\r\n\t\t\t\t\t)).value;\r\n\t\t\t\t\treturn a.getName() === name;\r\n\t\t\t\t});\r\n\t\t\t\t// Ejecutamos la operación según el valor del selector.\r\n\t\t\t\tif (operation === \"hacerAFD\") {\r\n\t\t\t\t\tautomaton = Misc.afnToAfd(automaton.copy());\r\n\t\t\t\t} else {\r\n\t\t\t\t\tautomaton[operation]();\r\n\t\t\t\t}\r\n\t\t\t\t// Mostramos al autómata en tabla.\r\n\t\t\t\tdocument.querySelector(\r\n\t\t\t\t\t\"#automaton-table\"\r\n\t\t\t\t).innerHTML = automaton.toHTMLTable();\r\n\t\t\t});\r\n\t};\r\n\t// Listeners para realizar las operaciones binarias.\r\n\r\n\texport const activateBtnExecuteTwo = (automata: Automaton[]) => {\r\n\t\tdocument\r\n\t\t\t.querySelector(\".btn-execute__two\")\r\n\t\t\t.addEventListener(\"click\", () => {\r\n\t\t\t\tconst operation = (<HTMLSelectElement>(\r\n\t\t\t\t\tdocument.querySelector(\"#operation\")\r\n\t\t\t\t)).value;\r\n\t\t\t\tconst a1 = automata.find(a => {\r\n\t\t\t\t\tconst name = (<HTMLSelectElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\"#automaton\")\r\n\t\t\t\t\t)).value;\r\n\t\t\t\t\treturn a.getName() === name;\r\n\t\t\t\t});\r\n\t\t\t\tconst a2 = automata.find(a => {\r\n\t\t\t\t\tconst name = (<HTMLSelectElement>(\r\n\t\t\t\t\t\tdocument.querySelector(\"#target-automaton\")\r\n\t\t\t\t\t)).value;\r\n\t\t\t\t\treturn a.getName() === name;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tconst copy: Automaton = a2.copy();\r\n\t\t\t\ta1[operation](copy);\r\n\t\t\t\tdocument.querySelector(\r\n\t\t\t\t\t\"#automaton-table\"\r\n\t\t\t\t).innerHTML = a1.toHTMLTable();\r\n\t\t\t});\r\n\t};\r\n\r\n\texport const close = () => {\r\n\t\t(<HTMLElement>document.querySelector(\"#main__home\")).style.display =\r\n\t\t\t\"none\";\r\n\t};\r\n}\r\n\r\nexport { ListenersHome };\r\n","import { Automaton } from \"../Automaton/Automaton\";\r\n\r\nnamespace ListenersLexic {\r\n    export const loadDFAs = (automata: Automaton[]) => {\r\n        document\r\n            .querySelector(\"#automaton-table\")\r\n            .addEventListener(\"DOMSubtreeModified\", event => {\r\n\t\t\t\tconst cheks = automata\r\n\t\t\t\t\t.filter(automaton => automaton.esAFD())\r\n                    .map(\r\n                        automaton =>\r\n                            `<div class=\"check\">\r\n\t\t\t\t\t\t\t\t<input \r\n\t\t\t\t\t\t\t\t\ttype=\"checkbox\" \r\n\t\t\t\t\t\t\t\t\tname=\"${automaton.getName()}\" \r\n\t\t\t\t\t\t\t\t\tclass=\"automaton-checkbox\" \r\n\t\t\t\t\t\t\t\t\tvalue=\"${automaton.getName()}\" />${automaton.getName()}\r\n\t\t\t\t\t\t\t</div>`\r\n                    )\r\n\t\t\t\t\t.reduce((tags, tag) => tags + \"\\n\" + tag, \"\");\r\n\t\t\t\tconsole.log(cheks);\r\n                document.querySelector(\"#afd-checks\").innerHTML = cheks;\r\n            });\r\n    };\r\n}\r\n\r\nexport { ListenersLexic };\r\n","import { ListenersHome } from \"./ts/Listeners/ListenersHome\";\r\nimport { ListenersLexic } from \"./ts/Listeners/ListenersLexic\";\r\nimport { Automaton } from \"./ts/Automaton/Automaton\";\r\n\r\n// Arreglo de autómatas creados localmente.\r\nconst automata: Automaton[] = [];\r\n(<HTMLDivElement>document.querySelector(\"#main__home\")).style.display = \"block\";\r\n(<HTMLDivElement>document.querySelector(\"#main__lexic\")).style.display = \"none\";\r\n// Ejecutamos los listeners de ListenersHome\r\n// Asignamos acciones a los elementos de entrada.\r\nListenersHome.init();\r\nListenersHome.activateBtnCreator(automata);\r\nListenersHome.activateBtnExecuteOne(automata);\r\nListenersHome.activateBtnExecuteTwo(automata);\r\nListenersHome.activateAutomatonSelector(automata);\r\nListenersHome.makeTargetAutomatonSelectorDynamic(automata);\r\nListenersLexic.loadDFAs(automata);\r\n// Listener para la opción de navegación a \"lexic\" (analizador sntáctico).\r\ndocument.querySelector(\"#to-lexic\").addEventListener(\"click\", event => {\r\n    event.preventDefault();\r\n    const currentlyHere = window.location.href\r\n        .split(\"/\")\r\n        .find(item => item === \"lexic\");\r\n    if (!currentlyHere) {\r\n        window.history.pushState(\r\n            {},\r\n            \"/lexic\",\r\n            window.location.origin + \"/lexic\"\r\n        );\r\n        (<HTMLDivElement>document.querySelector(\"#main__lexic\")).style.display =\r\n            \"initial\";\r\n        (<HTMLDivElement>document.querySelector(\"#main__home\")).style.display =\r\n            \"none\";\r\n        (<HTMLAnchorElement>document.querySelector(\"#to-lexic\")).classList.add(\r\n            \"active\"\r\n        );\r\n    }\r\n});\r\n\r\n// Listener para la navegación a \"home\"\r\ndocument.querySelector(\"#brand\").addEventListener(\"click\", event => {\r\n    event.preventDefault();\r\n    const currentlyHere = window.location.href\r\n        .split(\"/\")\r\n        .find(item => item === \"\");\r\n    if (!currentlyHere) {\r\n        window.history.pushState({}, \"/\", window.location.origin);\r\n        (<HTMLDivElement>document.querySelector(\"#main__home\")).style.display =\r\n            \"block\";\r\n        (<HTMLDivElement>document.querySelector(\"#main__lexic\")).style.display =\r\n            \"none\";\r\n    }\r\n});\r\n"]}