{"version":3,"sources":["ts/State/State.ts","ts/Transition/Transition.ts","ts/Misc/Misc.ts","ts/Automaton/Automaton.ts","main.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IACM;AAIL;;;;;AAKA,eAAY,EAAZ,EAAsB;AAAA;;AAAA;;AAKtB;;;;;;AAMA,OAAA,aAAA,GAAgB,UAAC,CAAD,EAAkB;AACjC,IAAA,KAAI,CAAC,WAAL,CAAiB,GAAjB,CAAqB,CAArB;AACA,GAFD;AAIA;;;;;;;;AAMO,OAAA,sBAAA,GAAyB,UAAC,MAAD,EAAmB;AAClD,WAAO,mBAAI,KAAI,CAAC,WAAT,EAAsB,MAAtB,CAA8B,UAAA,UAAU,EAAG;AACjD,UAAI,UAAU,CAAC,cAAX,EAAJ,EAAiC;AAChC,eAAO,MAAM,CAAC,MAAP,KAAkB,CAAlB,GAAsB,UAAU,CAAC,MAAX,IAAqB,MAArB,IAA+B,MAAM,IAAI,UAAU,CAAC,WAA1E,GAAwF,KAA/F;AACA,OAFD,MAEO;AACN,eAAO,UAAU,CAAC,MAAX,KAAsB,MAA7B;AACA;AACD,KANM,CAAP;AAOA,GARM;;AApBN,OAAK,EAAL,GAAU,EAAV;AACA,OAAK,WAAL,GAAmB,IAAI,GAAJ,EAAnB;AACA;;AA6BM,OAAA,CAAA,KAAA,GAAA,KAAA;;;;;;;;;;ICxCF,aAKL,oBAAa,MAAb,EAA6B,WAA7B,EAAiD,WAAjD,EAAqE;AAAA;;AAAA;;AAqBrE,OAAA,cAAA,GAAiB,YAAK;AACrB,WAAO,KAAI,CAAC,WAAL,GAAmB,IAAnB,GAA0B,KAAjC;AACA,GAFD,CArBqE,CACpE;;;AACA,OAAK,MAAL,GAAc,MAAd,CAFoE,CAGpE;;AACA,OAAK,WAAL,GAAmB,WAAnB,CAJoE,CAKpE;;AACA,MAAI,WAAJ,EAAiB;AAChB,QAAI,MAAM,CAAC,MAAP,IAAiB,CAAjB,IAAsB,WAAW,CAAC,MAAZ,IAAsB,CAAhD,EAAmD;AAClD,MAAA,OAAO,CAAC,GAAR,CAAY,wDAAZ;AACA,aAAO,IAAP;AACA;;AACD,QAAI,WAAW,IAAI,MAAnB,EAA2B;AAC1B,MAAA,OAAO,CAAC,GAAR,CAAY,kDAAZ;AACA,aAAO,IAAP;AACA;;AACD,SAAK,WAAL,GAAmB,WAAnB;AACA,GAVD,MAUO;AACN,SAAK,WAAL,GAAmB,IAAnB;AACA;AACD;;AAMM,OAAA,CAAA,UAAA,GAAA,UAAA;;;;;;;;;;;;;;;AC5BR,IAAU,IAAV;;AAAA,CAAA,UAAU,IAAV,EAAc;AACG,EAAA,IAAA,CAAA,OAAA,GAAkB,QAAlB;AAEb;;;;;;;;;;;AAUa,EAAA,IAAA,CAAA,IAAA,GAAO,UAAC,MAAD,EAAqB,MAArB,EAAuC,CAE1D,CAFY;AAIb;;;;;;;;;;;;AAUa,EAAA,IAAA,CAAA,IAAA,GAAO,UAAC,MAAD,EAAqB,MAArB,EAAuC,CAE1D,CAFY;AAKZ;;;;;;;;AAMY,EAAA,IAAA,CAAA,cAAA,GAAiB,UAAC,MAAD,EAAuB;AACjD,QAAM,WAAW,GAAG,mBAAI,MAAJ,EAAY,GAAZ,CAAgB,oBAAhB,CAApB;;AACA,WAAO,WAAW,CAAC,MAAZ,CAAmB,UAAC,KAAD,EAAQ,GAAR,EAAe;AACrC,MAAA,GAAG,CAAC,OAAJ,CAAY,UAAA,KAAK,EAAG;AAChB,QAAA,KAAK,CAAC,GAAN,CAAU,KAAV;AACH,OAFD;AAGA,aAAO,KAAP;AACH,KALM,EAKJ,IAAI,GAAJ,EALI,CAAP;AAMH,GARY;AAWb;;;;;;;;AAMA,MAAM,oBAAoB,GAAG,SAAvB,oBAAuB,CAAC,KAAD,EAAiB;AAC1C,WAAO,IAAI,GAAJ,CACH,mBAAI,KAAK,CAAC,WAAN,CAAkB,MAAlB,EAAJ,EACK,MADL,CACY,UAAA,UAAU;AAAA,aAAI,UAAU,CAAC,MAAX,KAAsB,IAAA,CAAA,OAA1B;AAAA,KADtB,EAEK,GAFL,CAES,UAAA,UAAU;AAAA,aAAI,UAAU,CAAC,WAAf;AAAA,KAFnB,CADG,CAAP;AAKH,GAND;AAQA;;;;;;;;;;;;AAWH,CA1ED,EAAU,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAd;;AA4EA,OAAA,CAAA,OAAA,GAAe,IAAf;;;;;;;;;;;;;;;;;;;;;;;;AChFA,IAAA,OAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AACA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;IAEM;AAqCF;;;;;AAKA,qBAAA;AAAA;;AAAA;;AAWA;;;;;;;AAOgB,OAAA,WAAA,GAAc,UAAC,MAAD,EAAiB,WAAjB,EAAyC;AACnE,QAAM,MAAM,GAAG,IAAI,OAAA,CAAA,KAAJ,CAAU,CAAV,CAAf;AACA,QAAM,MAAM,GAAG,IAAI,OAAA,CAAA,KAAJ,CAAU,CAAV,CAAf;AACA,QAAM,UAAU,GAAG,IAAI,YAAA,CAAA,UAAJ,CAAe,MAAf,EAAuB,MAAvB,EAA+B,WAA/B,CAAnB;AACA,IAAA,MAAM,CAAC,aAAP,CAAqB,UAArB,EAJmE,CAMnE;;AACA,QAAI,UAAU,CAAC,cAAX,EAAJ,EAAiC;AAC7B,WACI,IAAI,KAAK,GAAG,MAAM,CAAC,UAAP,CAAkB,CAAlB,CADhB,EAEI,KAAK,IAAI,WAAW,CAAC,UAAZ,CAAuB,CAAvB,CAFb,EAGI,KAAK,EAHT,EAIE;AACE,QAAA,KAAI,CAAC,KAAL,CAAW,GAAX,CAAe,MAAM,CAAC,YAAP,CAAoB,KAApB,CAAf;AACH;AACJ,KARD,MAQO;AACH,MAAA,KAAI,CAAC,KAAL,CAAW,GAAX,CAAe,MAAf;AACH,KAjBkE,CAmBnE;;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,MAAhB;;AACA,IAAA,KAAI,CAAC,UAAL,GAAkB,MAAlB;;AACA,IAAA,KAAI,CAAC,YAAL,CAAkB,GAAlB,CAAsB,MAAtB;AACH,GAxBe;AA0BhB;;;;;;;AAKgB,OAAA,YAAA,GAAe,YAAK;AAChC;AACA,QAAM,cAAc,GAAG,IAAI,OAAA,CAAA,KAAJ,CAAU,KAAI,CAAC,MAAL,CAAY,IAAtB,CAAvB,CAFgC,CAGhC;;AACA,QAAM,cAAc,GAAG,IAAI,OAAA,CAAA,KAAJ,CAAU,KAAI,CAAC,MAAL,CAAY,IAAZ,GAAmB,CAA7B,CAAvB,CAJgC,CAKhC;;AACA,QAAM,eAAe,GAAG,IAAI,YAAA,CAAA,UAAJ,CAAe,MAAA,CAAA,OAAA,CAAK,OAApB,EAA6B,cAA7B,CAAxB,CANgC,CAOhC;;AACA,QAAM,eAAe,GAAG,IAAI,YAAA,CAAA,UAAJ,CAAe,MAAA,CAAA,OAAA,CAAK,OAApB,EAA6B,KAAI,CAAC,UAAlC,CAAxB,CARgC,CAShC;;AACA,uBAAI,KAAI,CAAC,MAAT,EACK,MADL,CACY,UAAA,KAAK;AAAA,aAAI,KAAI,CAAC,YAAL,CAAkB,GAAlB,CAAsB,KAAtB,CAAJ;AAAA,KADjB,EAEK,OAFL,CAEa,UAAA,WAAW,EAAG;AACnB,MAAA,WAAW,CAAC,aAAZ,CAA0B,eAA1B;AACH,KAJL,EAVgC,CAehC;;;AACA,IAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB,GAhBgC,CAiBhC;;;AACA,IAAA,KAAI,CAAC,YAAL,CAAkB,GAAlB,CAAsB,cAAtB,EAlBgC,CAmBhC;;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,cAAhB;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,cAAhB,EArBgC,CAsBhC;;;AACA,IAAA,KAAI,CAAC,UAAL,GAAkB,cAAlB,CAvBgC,CAwBhC;;AACA,IAAA,KAAI,CAAC,UAAL,CAAgB,aAAhB,CAA8B,eAA9B;;AACA,IAAA,KAAI,CAAC,UAAL,CAAgB,aAAhB,CAA8B,eAA9B;AACH,GA3Be;AA6BhB;;;;;;;AAKgB,OAAA,YAAA,GAAe,YAAK;AAChC;AACA,QAAI,KAAI,CAAC,YAAL,CAAkB,IAAlB,IAA0B,CAA9B,EAAiC;AAC7B,MAAA,OAAO,CAAC,GAAR,CAAY,6CAAZ;AACA;AACH,KAL+B,CAOhC;;;AACA,QAAM,cAAc,GAAG,IAAI,OAAA,CAAA,KAAJ,CAAU,KAAI,CAAC,MAAL,CAAY,IAAtB,CAAvB,CARgC,CAShC;;AACA,QAAM,cAAc,GAAG,IAAI,OAAA,CAAA,KAAJ,CAAU,KAAI,CAAC,MAAL,CAAY,IAAZ,GAAmB,CAA7B,CAAvB,CAVgC,CAWhC;;AACA,QAAM,eAAe,GAAG,IAAI,YAAA,CAAA,UAAJ,CAAe,MAAA,CAAA,OAAA,CAAK,OAApB,EAA6B,cAA7B,CAAxB,CAZgC,CAahC;;AACA,QAAM,qBAAqB,GAAG,IAAI,YAAA,CAAA,UAAJ,CAC1B,MAAA,CAAA,OAAA,CAAK,OADqB,EAE1B,KAAI,CAAC,UAFqB,CAA9B,CAdgC,CAmBhC;;AACA;;;;AAGA,QAAM,cAAc,GAAG,mBAAI,KAAI,CAAC,YAAT,EAAuB,CAAvB,CAAvB;;AACA,IAAA,cAAc,CAAC,aAAf,CAA6B,qBAA7B;AACA,IAAA,cAAc,CAAC,aAAf,CAA6B,eAA7B;AAEA,IAAA,cAAc,CAAC,aAAf,CAA6B,qBAA7B;;AACA,IAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB;;AACA,IAAA,KAAI,CAAC,YAAL,CAAkB,GAAlB,CAAsB,cAAtB;;AACA,IAAA,KAAI,CAAC,UAAL,GAAkB,cAAlB;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,cAAhB;;AACA,IAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,cAAhB;AACH,GAjCe;AAmChB;;;;;;;AAKA,OAAA,UAAA,GAAa,YAAK;AACd;AACA,IAAA,KAAI,CAAC,YAAL;;AACA,QAAM,eAAe,GAAG,IAAI,YAAA,CAAA,UAAJ,CACpB,MAAA,CAAA,OAAA,CAAK,OADe,EAEpB,mBAAI,KAAI,CAAC,YAAT,EAAuB,CAAvB,CAFoB,CAAxB,CAHc,CAOd;;AACA,IAAA,KAAI,CAAC,UAAL,CAAgB,aAAhB,CAA8B,eAA9B;AACH,GATD;AAWA;;;;;;;;;;;AASgB,OAAA,QAAA,GAAW,UAAC,EAAD,EAAa,KAAb,EAAgC;AACvD,QAAI,KAAJ,EAAW;AACP,aAAO,mBAAI,KAAI,CAAC,YAAT,EAAuB,MAAvB,CAA8B,UAAA,KAAK;AAAA,eAAI,KAAK,CAAC,EAAN,KAAa,EAAjB;AAAA,OAAnC,EAAwD,CAAxD,CAAP;AACH;;AACD,WAAO,mBAAI,KAAI,CAAC,MAAT,EAAiB,MAAjB,CAAwB,UAAA,KAAK;AAAA,aAAI,KAAK,CAAC,EAAN,KAAa,EAAjB;AAAA,KAA7B,EAAkD,CAAlD,CAAP;AACH,GALe;;AAOA,OAAA,WAAA,GAAc,YAAK;AAC/B,QAAM,QAAQ,GAAG,IAAI,GAAJ,8BAAoB,KAAI,CAAC,KAAzB,IAAgC,MAAA,CAAA,OAAA,CAAK,OAArC,GAAjB,CAD+B,CAE/B;;AACA,QAAM,IAAI,GACN,SACA,mBAAI,QAAJ,EAAc,MAAd,CACI,UAAC,SAAD,EAAY,MAAZ;AAAA,aAAuB,SAAS,iBAAU,MAAV,UAAhC;AAAA,KADJ,EAEI,iBAFJ,CADA,GAKA,OANJ,CAH+B,CAU/B;;AACA,QAAM,IAAI,GAAG,mBAAI,KAAI,CAAC,MAAT,EACR,GADQ,CACJ,UAAA,KAAK,EAAG;AACT;AACA,UAAI,SAAJ;;AACA,UAAI,KAAI,CAAC,UAAL,KAAoB,KAAxB,EAA+B;AAC3B,QAAA,SAAS,+CACL,KAAK,CAAC,EADD,cAAT;AAGH,OAJD,MAIO,IAAI,KAAI,CAAC,YAAL,CAAkB,GAAlB,CAAsB,KAAtB,CAAJ,EAAkC;AACrC,QAAA,SAAS,gDACL,KAAK,CAAC,EADD,cAAT;AAGH,OAJM,MAIA;AACH,QAAA,SAAS,yCACL,KAAK,CAAC,EADD,cAAT;AAGH,OAfQ,CAgBT;;;AACA,UAAI,eAAe,GAAW,EAA9B;AAjBS;AAAA;AAAA;;AAAA;AAkBT,6BAAmB,QAAnB,8HAA6B;AAAA,cAApB,MAAoB;AACzB,cAAM,YAAY,GAAG,KAAK,CACrB,sBADgB,CACO,MADP,EAEhB,GAFgB,CAEZ,UAAA,UAAU;AAAA,6BAAO,UAAU,CAAC,WAAX,CAAuB,EAA9B;AAAA,WAFE,EAGhB,IAHgB,CAGX,IAHW,CAArB;AAIA,cAAM,IAAI,kBACN,YAAY,CAAC,MAAb,GAAsB,CAAtB,GAA0B,YAA1B,GAAyC,GADnC,WAAV;AAGA,UAAA,eAAe,IAAI,IAAnB;AACH,SA3BQ,CA4BT;;AA5BS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6BT,2BAAc,SAAd,SAA0B,eAA1B;AACH,KA/BQ,EAgCT;AAhCS,KAiCR,IAjCQ,CAiCH,EAjCG,CAAb;;AAkCA,4BAAiB,IAAjB,SAAwB,IAAxB;AACH,GA9Ce;;AArJZ,OAAK,KAAL,GAAa,IAAI,GAAJ,EAAb;AACA,OAAK,KAAL,CAAW,KAAX;AACA,OAAK,MAAL,GAAc,IAAI,GAAJ,EAAd;AACA,OAAK,MAAL,CAAY,KAAZ;AACA,OAAK,UAAL,GAAkB,IAAlB;AACA,OAAK,YAAL,GAAoB,IAAI,GAAJ,EAApB;AACA,OAAK,YAAL,CAAkB,KAAlB;AACA,EAAA,OAAO,CAAC,GAAR,CAAY,wBAAZ;AACH;;AA8LG,OAAA,CAAA,SAAA,GAAA,SAAA;;;;;;;;;;;;;;ACrPR,IAAA,WAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAEA,IAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,IAAM,SAAS,GAAG,IAAI,WAAA,CAAA,SAAJ,EAAlB;AACA,SAAS,CAAC,WAAV,CAAsB,GAAtB,EAA2B,GAA3B;AACA,SAAS,CAAC,UAAV;AACA,OAAO,CAAC,GAAR,CAAY,MAAA,CAAA,OAAA,CAAK,cAAL,CAAoB,IAAI,GAAJ,CAAe,CAAC,SAAS,CAAC,QAAV,CAAmB,CAAnB,CAAD,CAAf,CAApB,CAAZ;AACA,IAAM,UAAU,GAAG,QAAQ,CAAC,cAAT,CAAwB,iBAAxB,CAAnB;AACA,IAAM,GAAG,GAAG,SAAS,CAAC,WAAV,EAAZ;AACA,UAAU,CAAC,SAAX,GAAuB,GAAvB","file":"main.c39d6dcf.map","sourceRoot":"..","sourcesContent":["import {Transition} from \"../Transition/Transition\";\r\nclass State {\r\n\tpublic readonly id: number;\r\n\tpublic readonly transitions: Set<Transition>;\r\n\r\n\t/**\r\n\t * Crea un estado.\r\n\t *\r\n\t * @param id {identidiacdor del estado}\r\n\t */\r\n\tconstructor(id: number) {\r\n\t\tthis.id = id;\r\n\t\tthis.transitions = new Set<Transition>();\r\n\t}\r\n\r\n\t/**\r\n\t * Agrega una transición al conjunto de transiciones del estado.\r\n\t *\r\n\t * @param {Transition} t {transición a ser agregada}\r\n\t * @memberof State\r\n\t */\r\n\taddTransition = (t: Transition) => {\r\n\t\tthis.transitions.add(t);\r\n\t};\r\n\r\n\t/**\r\n\t * Obtiene el subconjunto del conjunto de transiciones que tengan el símbolo symbol.\r\n\t *\r\n\t * @param {string} symbol {símbolo con el que se hace la transición}\r\n\t * @memberof State\r\n\t */\r\n\tpublic getTransitionsBySymbol = (symbol: string) => {\r\n\t\treturn [...this.transitions].filter( transition => {\r\n\t\t\tif (transition.hasLimitSymbol()) {\r\n\t\t\t\treturn symbol.length === 1 ? transition.symbol <= symbol && symbol <= transition.limitSymbol : false;\r\n\t\t\t} else {\r\n\t\t\t\treturn transition.symbol === symbol;\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n}\r\n\r\nexport {State};\r\n","import {State} from \"../State/State\";\r\n\r\nclass Transition {\r\n\tpublic symbol: string;\r\n\tpublic limitSymbol: string;\r\n\tpublic targetState: State;\r\n\r\n\tconstructor (symbol: string, targetState: State, limitSymbol?: string) {\r\n\t\t// Se sgrega el símbolo principal de la transición.\r\n\t\tthis.symbol = symbol;\r\n\t\t// Se establece el estado objetivo.\r\n\t\tthis.targetState = targetState;\r\n\t\t// Se establece el símbolo límite (para rangos), si existe.\r\n\t\tif (limitSymbol) {\r\n\t\t\tif (symbol.length != 1 || limitSymbol.length != 1) {\r\n\t\t\t\tconsole.log(\"La longitud de ambos símbolos para un rango debe ser 1\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tif (limitSymbol <= symbol) {\r\n\t\t\t\tconsole.log(\"No es posible crear la transición con ese rango.\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tthis.limitSymbol = limitSymbol;\r\n\t\t} else {\r\n\t\t\tthis.limitSymbol = null;\r\n\t\t}\r\n\t}\r\n\r\n\thasLimitSymbol = () => {\r\n\t\treturn this.limitSymbol ? true : false;\r\n\t}\r\n}\r\nexport {Transition};","import {Automaton} from \"../Automaton/Automaton\";\r\nimport {State} from \"../State/State\";\r\nimport {Transition} from \"../Transition/Transition\";\r\n\r\nnamespace Misc {\r\n    export const EPSILON: string = \"\\u03B5\";\r\n\r\n    /**\r\n     * Función Ir_a(). Aplica la función Mover() con los parámetros\r\n     * \"states\" que es un conjunto de estados y \"symbol\" que es un\r\n     * símbolo. Al resultado se le \r\n     * \r\n     *\r\n     * @param {Set<State>} states\r\n     * @param {string} symbol\r\n     * @returns {Set<State>}\r\n     */\r\n    export const goTo = (states: Set<State>, symbol: string) => {\r\n\r\n    };\r\n\r\n    /**\r\n     * Función Mover(). Obtiene el conjunto de estados al que se \r\n     * puede acceder desde otro conjunto de estados \"states\"\r\n     * estrictamente mediante transiciones con un símbolo \"symbol\"\r\n     * dado.\r\n     *\r\n     * @param {Set<State>} setOfStates\r\n     * @param {string} symbol\r\n     * @returns {Set<State>}\r\n     */\r\n    export const move = (states: Set<State>, symbol: string) => {\r\n        \r\n    };\r\n\r\n\r\n     /**\r\n     * Obtiene la cerradura épsilon de un conjunto de estados.\r\n     *\r\n     * @param {Set<State>} states\r\n     * @returns {Set<State>}\r\n     */\r\n    export const epsilonClosure = (states: Set<State>) => {\r\n        const epsilonSets = [...states].map(simpleEpsilonClosure);\r\n        return epsilonSets.reduce((union, set) => {\r\n            set.forEach(state => {\r\n                union.add(state);\r\n            });\r\n            return union;\r\n        }, new Set<State>());\r\n    };\r\n\r\n\r\n    /**\r\n     * Obtiene la cerradura épsilon de un estado.\r\n     *\r\n     * @param {State} state\r\n     * @returns {Set<State>}\r\n     */\r\n    const simpleEpsilonClosure = (state: State) => {\r\n        return new Set<State>(\r\n            [...state.transitions.values()]\r\n                .filter(transition => transition.symbol === EPSILON)\r\n                .map(transition => transition.targetState)\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Para el análisis léxico, tomamos el último estado de aceptación\r\n     * con el que se obtuvo un token y se guarda el índice hasta que, con\r\n     * caracteres siguientes, no se pueda hacer otra transición.\r\n     *\r\n     * En ese momento, se corta la cadena hasta el índice con el que se tuvo el\r\n     * último token y se empieza el proceso de nuevo.\r\n     *\r\n     *\r\n     * LIBRO: Compiler design in C.\r\n     */\r\n}\r\n\r\nexport default Misc;\r\n","import {State} from \"../State/State\";\r\nimport {Transition} from \"../Transition/Transition\";\r\nimport Misc from \"../Misc/Misc\";\r\n\r\nclass Automaton {\r\n    /**\r\n     * Alfabeto del autómata.\r\n     *\r\n     * @private\r\n     * @type {Set<string>}\r\n     * @memberof Automaton\r\n     */\r\n    private sigma: Set<string>;\r\n\r\n    /**\r\n     * Conjunto de estados del autómata.\r\n     *\r\n     * @private\r\n     * @type {Set<State>}\r\n     * @memberof Automaton\r\n     */\r\n    private states: Set<State>;\r\n\r\n    /**\r\n     * Estado inicial del autómata.\r\n     *\r\n     * @private\r\n     * @type {State}\r\n     * @memberof Automaton\r\n     */\r\n    private startState: State;\r\n\r\n    /**\r\n     * Conjunto de estados de aceptación del autómata.\r\n     *\r\n     * @private\r\n     * @type {Set<State>}\r\n     * @memberof Automaton\r\n     */\r\n    private acceptStates: Set<State>;\r\n\r\n    /**\r\n     * Genera un autómata vacío.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    constructor() {\r\n        this.sigma = new Set<string>();\r\n        this.sigma.clear();\r\n        this.states = new Set<State>();\r\n        this.states.clear();\r\n        this.startState = null;\r\n        this.acceptStates = new Set<State>();\r\n        this.acceptStates.clear();\r\n        console.log(\"Automata vacío creado.\");\r\n    }\r\n\r\n    /**\r\n     * Crea un autómata básico de una transición con el símbolo symbol.\r\n     *\r\n     * @param {string} symbol {es el símbolo con el que se genera la transición}\r\n     * @param {string} [limitSymbol] {es un símbolo opcional que delimita el rango [symbol, limitSymbol]}\r\n     * @memberof Automaton\r\n     */\r\n    public readonly createBasic = (symbol: string, limitSymbol?: string) => {\r\n        const state0 = new State(0);\r\n        const state1 = new State(1);\r\n        const transition = new Transition(symbol, state1, limitSymbol);\r\n        state0.addTransition(transition);\r\n\r\n        // Se agregan los símbolos que abarca el rango (symbol, limitSymbol) a sigma.\r\n        if (transition.hasLimitSymbol()) {\r\n            for (\r\n                let ascii = symbol.charCodeAt(0);\r\n                ascii <= limitSymbol.charCodeAt(0);\r\n                ascii++\r\n            ) {\r\n                this.sigma.add(String.fromCharCode(ascii));\r\n            }\r\n        } else {\r\n            this.sigma.add(symbol);\r\n        }\r\n\r\n        // Agregamos los estados a los conjuntos y establecemos estados inicial y finales.\r\n        this.states.add(state0);\r\n        this.states.add(state1);\r\n        this.startState = state0;\r\n        this.acceptStates.add(state1);\r\n    };\r\n\r\n    /**\r\n     * Crea la forma opcional del autómata.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    public readonly makeOptional = () => {\r\n        // Se crea el estado inicial auxiliar.\r\n        const nextBeginState = new State(this.states.size);\r\n        // Se crea el estado final auxiliar.\r\n        const nextFinalState = new State(this.states.size + 1);\r\n        // Se crea transición épsilon que va al estado final.\r\n        const finalTransition = new Transition(Misc.EPSILON, nextFinalState);\r\n        // Se crea transición épsilon que partirá del nuevo estado inicial.\r\n        const firstTransition = new Transition(Misc.EPSILON, this.startState);\r\n        // Se agrega la transición final nueva a todos los estados finales.\r\n        [...this.states]\r\n            .filter(state => this.acceptStates.has(state))\r\n            .forEach(acceptState => {\r\n                acceptState.addTransition(finalTransition);\r\n            });\r\n        // Se limpia el conjunto de estados finales.\r\n        this.acceptStates.clear();\r\n        // Y se reemplaza solo por el nuevo estado final.\r\n        this.acceptStates.add(nextFinalState);\r\n        // Se agregan los estados nuevos al conjunto de estados.\r\n        this.states.add(nextBeginState);\r\n        this.states.add(nextFinalState);\r\n        // Se reemplaza el nuevo estado inicial.\r\n        this.startState = nextBeginState;\r\n        // Se le agregan las transiciones al inicio antiguo del autómata y al final del mismo.\r\n        this.startState.addTransition(firstTransition);\r\n        this.startState.addTransition(finalTransition);\r\n    };\r\n\r\n    /**\r\n     * Crea la forma positiva del autómata.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    public readonly makePositive = () => {\r\n        // Nos aseguramos de que solo haya un estado final.\r\n        if (this.acceptStates.size != 1) {\r\n            console.log(\"El autómata no tiene un único estado final.\");\r\n            return;\r\n        }\r\n\r\n        // Se crea el estado inicial auxiliar.\r\n        const nextBeginState = new State(this.states.size);\r\n        // Se crea el estado final auxiliar.\r\n        const nextFinalState = new State(this.states.size + 1);\r\n        // Se crea transición épsilon que va al estado final.\r\n        const finalTransition = new Transition(Misc.EPSILON, nextFinalState);\r\n        // Se crea transición épsilon que va hacia el viejo estado inicial.\r\n        const toPrevStartTransition = new Transition(\r\n            Misc.EPSILON,\r\n            this.startState\r\n        );\r\n\r\n        // Agregamos transiciones a los respectivos estados.\r\n        /* const prevFinalState = [...this.states].filter(state =>\r\n\t\t\tthis.acceptStates.has(state)\r\n\t\t)[0];*/\r\n        const prevFinalState = [...this.acceptStates][0];\r\n        prevFinalState.addTransition(toPrevStartTransition);\r\n        prevFinalState.addTransition(finalTransition);\r\n\r\n        nextBeginState.addTransition(toPrevStartTransition);\r\n        this.acceptStates.clear();\r\n        this.acceptStates.add(nextFinalState);\r\n        this.startState = nextBeginState;\r\n        this.states.add(nextBeginState);\r\n        this.states.add(nextFinalState);\r\n    };\r\n\r\n    /**\r\n     * Crea la forma de Kleene del autómata.\r\n     *\r\n     * @memberof Automaton\r\n     */\r\n    makeKleene = () => {\r\n        // Se hace la cerradura positiva del autómata\r\n        this.makePositive();\r\n        const transitionToEnd = new Transition(\r\n            Misc.EPSILON,\r\n            [...this.acceptStates][0]\r\n        );\r\n        // Se agrega la transición épsilon del inicio al fin del autómata.\r\n        this.startState.addTransition(transitionToEnd);\r\n    };\r\n\r\n    /**\r\n     * Obtiene un estado mediante el identificador suministrado. Se puede indicar si es un estado terminal.\r\n     *\r\n     * @private\r\n     * @param {number} id {identificador del estado en this.states}\r\n     * @param {boolean} [final] {bandera que indica si pertenece a this.acceptStates}\r\n     * @returns {State} {estado que coincide con la consulta}\r\n     * @memberof Automaton\r\n     */\r\n    public readonly getState = (id: number, final?: boolean) => {\r\n        if (final) {\r\n            return [...this.acceptStates].filter(state => state.id === id)[0];\r\n        }\r\n        return [...this.states].filter(state => state.id === id)[0];\r\n    };\r\n\r\n    public readonly toHTMLTable = () => {\r\n        const tmpSigma = new Set<string>([...this.sigma, Misc.EPSILON]);\r\n        // Encabezado de la tabla.\r\n        const head =\r\n            \"<tr>\" +\r\n            [...tmpSigma].reduce(\r\n                (tableHead, symbol) => tableHead + `<th>${symbol}</th>`,\r\n                \"<th>Estado</th>\"\r\n            ) +\r\n            \"</tr>\";\r\n        // Cuerpo (filas) de la tabla.\r\n        const body = [...this.states]\r\n            .map(state => {\r\n                // Celda del estado actual.\r\n                let stateCell: string;\r\n                if (this.startState === state) {\r\n                    stateCell = `<td class=\"state-cell start\"><p>${\r\n                        state.id\r\n                    }</p></td>`;\r\n                } else if (this.acceptStates.has(state)) {\r\n                    stateCell = `<td class=\"state-cell accept\"><p>${\r\n                        state.id\r\n                    }</p></td>`;\r\n                } else {\r\n                    stateCell = `<td class=\"state-cell\"><p>${\r\n                        state.id\r\n                    }</p></td>`;\r\n                }\r\n                // Resto de la fila.\r\n                let targetStatesRow: string = \"\";\r\n                for (let symbol of tmpSigma) {\r\n                    const targetStates = state\r\n                        .getTransitionsBySymbol(symbol)\r\n                        .map(transition => `${transition.targetState.id}`)\r\n                        .join(\", \");\r\n                    const cell = `<td>{${\r\n                        targetStates.length > 0 ? targetStates : \" \"\r\n                    }}</td>`;\r\n                    targetStatesRow += cell;\r\n                }\r\n                //Fila completa.\r\n                return `<tr>${stateCell}${targetStatesRow}</tr>`;\r\n            })\r\n            // Se unen (concatenan) todas las filas\r\n            .join(\"\");\r\n        return `<table>${head}${body}</table>`;\r\n    };\r\n}\r\n\r\nexport {Automaton};\r\n","import {Automaton} from \"./ts/Automaton/Automaton\";\r\nimport {State} from \"./ts/State/State\";\r\nimport Misc from \"./ts/Misc/Misc\";\r\nconst automaton = new Automaton();\r\nautomaton.createBasic(\"a\", \"z\");\r\nautomaton.makeKleene();\r\nconsole.log(Misc.epsilonClosure(new Set<State>([automaton.getState(0)])));\r\nconst containter = document.getElementById(\"automaton-table\");\r\nconst str = automaton.toHTMLTable();\r\ncontainter.innerHTML = str;"]}